# Стек

## Синтаксис
```
template <typename T>
struct Node {   
  T value;          // стойност на полето
  Node<T>* next;    // връзка към следващото поле
};
```

- LIFO методология



### std::stack

- top() -> Връща стойността на елемента, намиращ се във върха на стека
- push(*x*) -> Добавя нов елемент със стойност *x* във върха на стека
- pop() -> Премахва елемент от върха на стека
- empty() -> Проверява дали стекът е празен. Връща true, ако е така, и false в противен случай



## Задачи

#### Задача 1
Скоба наричаме следните символи: **(**, **)**, **[**, **]**, **{** и **}**. Считаме две скоби за двойка, ако са съответно отваряща и затваряща от един и същи тип - **(**-**)**, **[**\-**]**. **{**-**}**. Скобите не са балансирани, ако поредността на отваряне и затваряне не е спазена (пример: **([(])** или **[{(})[)**. С други думи една поредица от скоби е балансирана, ако:
- външните скоби съвпадат
- поредността, разположена между външните скоби, е балансирана 

По зададена поредност от скоби да се определи дали тя е балансирана или не.


**Пример:** 

*Вход:* {{[[(())]]}} \
*Изход:* Yes


*Вход:* {[(])} \
*Изход:* No


##
#### Задача 2
В една градина са засадени цветя в редица. Всеки ден всяко от тях се третира с определено количество пестициди. Ако в даден ден някое цвете е третирано с повече пестициди от това вляво от него, то умира. Дадени са стойностите на пестицидите за всяко едно растение. Те са еднакви за всички дни. Да се определи след колко дни вече няма да умират цветя.

**Пример:**

*Вход:* \
5 \
3 6 2 7 5 \
*Изход:* 2

**Обяснение на примера:** 

В началото са засадени цветя, пръскани със следните пестициди:
| 3 | 6 | 2 | 7 | 5 |
| - | - | - | - | - |
| 1 | 2 | 3 | 4 | 5 |

След първия ден цветя с номера 2 и 4 умират.
| 3 | 2 | 5 |
| - | - | - |
| 1 | 3 | 5 |

След втория ден умира цвете с номер 5. Повече цветя няма да умират.
| 3 | 2 |
| - | - |
| 1 | 3 |


##
#### Задача 3
Сервитьор разполага с куп номерирани чинии и два подноса - **B**, на който се слагат чиниите, които ще бъдат сервирани на дадена итерация, и **A**, на който се заделят чинии за следваща итерация. На всяка итерация **i** през салона, той раздава чиниите на следния принцип:
- взима най-горната чиния
- ако номерът й се дели на **i**-тото просто число, то го добавя на поднос **B**
- в противен случай, го добавя на поднос **A**
- в края на итерацията раздава чиниите от поднос **B**
- изпълнява следващата итерация с поднос **А**

На стандартния вход са дадени брой чинии и брой итерации, последвани от номерата чинии (от дъното към върха на купа). Нека след всяка итерация на стандартния изход се изведат номерата на чиниите в реда на сервиране. След приключване на последната итерация да се изведат номерата на оставащите чинии.

**Пример:**

*Вход:* \
6 \
3 \
2 3 4 5 6 7 

*Изход:* \
2 4 6 3 5 7

**Обяснение на примера:** 

Прости числа: **2**, **3**, **5**, **7**…. \
Ще разгледаме **3** итерации.

- Първа итерация: \
Куп чинии: **2**, **3**, **4**, **5**, **6**, **7** \
Проверяваме за деление на **2**. \
В края на итерацията: \
***B***: **6**, **4**, **2** \
***A***: **7**, **5**, **3**

- Втора итерация: \
Куп чинии: **7**, **5**, **3** \
Проверяваме за деление на **3**. \
В края на итерацията: \
***B***: **3** \
***A***: **5**, **7**

- Трета итерация: \
Куп чинии: **5**, **7** \
Проверяваме за деление на **5**. \
В края на итерацията: \
***B***: **5** \
***A***: **7**

