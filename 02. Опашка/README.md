# Опашка

## Синтаксис

- FIFO методология



### std::queue

- front() -> Връща стойността на елемента, намиращ се в главата на опашката
- push(*x*) -> Добавя нов елемент със стойност *x* в края на стека
- pop() -> Премахва елемент от главата на опашката
- empty() -> Проверява дали опашката е празна. Връща true, ако е така, и false в противен случай



## Задачи

#### Задача 1
Ванката и Аня имат следната игра: взимат подредено тесте от **N** карти, номерирани от **1** до **N**, като карта **№1** е разположена най-отгоре. След това изпълняват следния алгоритъм, докато в тестето не остане само една карта:
- най-горната карта се изхвърля
- картата, която сега е най-отгоре се премества най-отдолу в тестето

Аня се интересува да разбере в какъв ред биха били премахнати картите. Ванката пък се вълнува повече коя карта би останала накрая. На стандартния вход е дадено цяло число **N**. Да се изведе на един ред от стандартния изход последователността на премахване на карти от тестето, последван от ред само с едно число - оставащата карта.

**Пример:**

*Вход:* 19 \
*Изход:* 1 3 5 7 9 11 13 15 17 19 4 8 12 16 2 10 18 14 6



##
#### Задача 2
Време е за парад! Всяка година организаторите украсяват редица автомобили по случай празника на града и обикалят по главните улици с тях. Проблемът е, че началната улица е прекалено тясна, за да е възможно два автомобила да се разминат, а самите организатори не винаги украсяват автомобилите в правилната последователност. За щастие, близо до изхода на улицата има отбивка, която могат да използват за допълнително пространство. Също така, веднъж влезли в отбивката, автомобилите не могат да се връщат назад - единственият им изход е да продължат в посоката на парада. Дадена е последователността, в която са украсени автомобилите. Да се изведе **yes**, ако чрез маневри в страничната улица могат да се подредят правилно, и **no** - в противен случай.

**Пример:**

*Вход:* \
5 \
5 1 2 4 3 \
*Изход:* yes

**Пример:**

*Вход:* \
5 \
5 2 4 3 1 \
*Изход:* no



##
#### Задача 3
Ванката се учи да разпознава структурите от данни. Това не върви особено успешно, затова си измисля следното упражнение: надписва няколко картички с различни цели числа. След това на всеки ход слага нова картичка в кутия или тегли една от вече озовалите се вътре. Според поредицата изтеглени картички, се опитва да разпознае дали кутията се държи като стек, като опашка или като нито едно от двете. На стандартния вход е дадено цяло число **N** - броя операции. На следващите **N** на брой реда са изредени по **2** числа - код на операция (**1** за слагане в кутията и **2** за теглене) и номер на картичка. На стандартния изход да се изведе **queue**, ако кутията се разпознава като опашка, **stack**, ако се разпознава като стек, **both** - ако може да е и двете, **nothing** - ако не се държи като нито едното.

**Пример:**

*Вход:* \
6  \
1 1  \
1 2  \
1 3  \
2 1  \
2 2  \
2 3  \
*Изход:* queue

*Вход:* \
6  \
1 1  \
1 2  \
1 3  \
2 3  \
2 2  \
2 1  \
*Изход:* stack
