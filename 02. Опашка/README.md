# Опашка

## Синтаксис

Ще използваме следната структура, представяща елемент на опашката 
```c++
template <typename T>
struct Node {   
  T value;          // стойност на полето
  Node<T>* next;    // връзка към следващото поле

  Node(const T& value, Node<T>* next=nullptr): value(value), next(next) {}
};
```

**FIFO методология** - First-In-First-Out (първи влязъл, първи излязъл)

**Стандартни методи за работа с опашка:**
- **front()** -> Връща стойността на елемента, намиращ се в началото на опашката (head)
<pre>
     head
      v
     -----------
q =   x | y | z  <- tail       q.front() -> x
     -----------
</pre>


- **push(*value*)** -> Добавя нов елемент със стойност *value* в края на опашката (tail)
<pre>
     head                                        head
      v                                           v
     -----------                                 ---------------
q =   x | y | z  <- tail       q.push(a) -> q =   x | y | z | a  <- tail
     -----------                                 ---------------
</pre>

```c++
template <typename T>
void push(const T& value, Node<T>*& head) {
  if(!head) {
    head = new Node<T>(value);
    return;
  }
  if(!head-next) {
    head->next = new Node<T>(value);
    return;
  }
  push(value, head->next);
}
```

- **pop()** -> Премахва елемент от началото на опашката (head)
<pre>
     head                                          head
      v                                             v
     ---------------                               -----------
q =   a | x | y | z  <- tail       q.pop() -> q =   x | y | z  <- tail
     ---------------                               -----------
</pre>

```c++
template <typename T>
void pop(Node<T>*& head) {
  if(!head) return;

  Node<T>* to_be_deleted = head;
  head = head->next;
  delete to_be_deleted;
}
```

- **empty()** -> Проверява дали опашката е празна. Връща true, ако е така, и false в противен случай
<pre>
     head                 
      v                        
     ---------------                               
q =   a | x | y | z  <- tail       q.empty() -> false
     ---------------    

     head                 
      v                        
     ---                           
q =       <- tail       q.empty() -> true
     ---                                     
</pre>


### std::queue

**Библиотека:** queue
**Дефиниция:**  std::queue<*T*> - празна опашка от тип *T*

**Вградени методи:**
- front() -> Връща стойността на елемента, намиращ се в началото на опашката
- push(*x*) -> Добавя нов елемент със стойност *x* в края на опашката
- pop() -> Премахва елемент от началото на опашката
- empty() -> Проверява дали опашката е празна. Връща true, ако е така, и false в противен случай



## Задачи

#### Задача 1
Ванката и Аня имат следната игра: взимат подредено тесте от **N** карти, номерирани от **1** до **N**, като карта **№1** е разположена най-отгоре. След това изпълняват следния алгоритъм, докато в тестето не остане само една карта:
- най-горната карта се изхвърля
- картата, която сега е най-отгоре се премества най-отдолу в тестето

Аня се интересува да разбере в какъв ред биха били премахнати картите. Ванката пък се вълнува повече коя карта би останала накрая. На стандартния вход е дадено цяло число **N**. Да се изведе на един ред от стандартния изход последователността на премахване на карти от тестето, последван от ред само с едно число - оставащата карта.

**Пример:**

*Вход:* 19 \
*Изход:* \
1 3 5 7 9 11 13 15 17 19 4 8 12 16 2 10 18 14 \ 
6



##
#### Задача 2
Време е за парад! Всяка година организаторите украсяват редица автомобили по случай празника на града и обикалят по главните улици с тях. Проблемът е, че началната улица е прекалено тясна, за да е възможно два автомобила да се разминат, а самите организатори не винаги украсяват автомобилите в правилната последователност. За щастие, близо до изхода на улицата има отбивка, която могат да използват за допълнително пространство. Също така, веднъж влезли в отбивката, автомобилите не могат да се връщат назад - единственият им изход е да продължат в посоката на парада. Дадена е последователността, в която са украсени автомобилите. Да се изведе **yes**, ако чрез маневри в страничната улица могат да се подредят правилно, и **no** - в противен случай.

**Пример:** \
*Вход:* \
5 \
5 1 2 4 3 \
*Изход:* yes

*Илюстрация:*
<pre>
                head
                 v
        ----------------------- 
tail ->  3 1 2 4 5            ->
        -------------    ------
                    |    |
                    |    |
                    |----|
</pre>

**Пример:** \
*Вход:* \
5 \
5 2 4 3 1 \
*Изход:* no

*Илюстрация:*
<pre>
                head                                   head
                 v                                      v
        -----------------------                       --------------
tail ->  1 3 4 2 5            ->       ==>   tail ->            1 -> 
        -------------    ------                       ----    ------
                    |    |                       top ->  | 3 |
                    |    |                               | 4 |
                    |----|                               | 2 |
                                                         | 5 |
                                                         |---|

</pre>


##
#### Задача 3
Ванката се учи да разпознава структурите от данни. Това не върви особено успешно, затова си измисля следното упражнение: надписва няколко картички с различни цели числа. След това на всеки ход слага нова картичка в кутия или тегли една от вече озовалите се вътре. Според поредицата изтеглени картички, се опитва да разпознае дали кутията се държи като стек, като опашка или като нито едно от двете. На стандартния вход е дадено цяло число **N** - броя операции. На следващите **N** на брой реда са изредени по **2** числа - код на операция (**1** за слагане в кутията и **2** за теглене) и номер на картичка. На стандартния изход да се изведе **queue**, ако кутията се разпознава като опашка, **stack**, ако се разпознава като стек, **both** - ако може да е и двете, **nothing** - ако не се държи като нито едното.

**Пример:**

*Вход:* \
6  \
1 1  \
1 2  \
1 3  \
2 1  \
2 2  \
2 3  \
*Изход:* queue

*Вход:* \
6  \
1 1  \
1 2  \
1 3  \
2 3  \
2 2  \
2 1  \
*Изход:* stack
