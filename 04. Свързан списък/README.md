# Свързан списък

## Синтаксис

Ще използваме следната структура, представяща елемент на списъка
```c++
template <typename T>
struct Node {   
  T value;          // стойност на полето
  Node<T>* next;    // връзка към следващото поле

  Node(const T& value, Node<T>* next=nullptr): value(value), next(next) {}
};
```

**Стандартни методи за работа със свързан списък:**
- **front()** -> Връща стойността на елемента, намиращ се в началото на списъка (start)
<pre>
     start        
      v             
      ---    ---    ---
l =  | x |->| y |->| z |       l.front() -> x
      ---    ---    ---
</pre>


- **push_front(*value*)** -> Добавя нов елемент със стойност *value* в началото на списъка (start)
<pre>
     start                                              start
      v                                                   v
      ---    ---    ---                                  ---    ---    ---    ---
l =  | x |->| y |->| z |        l.push_front(a) -> l =  | a |->| x |->| y |->| z |  
      ---    ---    ---                                  ---    ---    ---    ---
</pre>

```c++
template <typename T>
void push_front(const T& value, Node<T>*& head) {
  head = new Node<T>(value, head);
}
```

- **pop_front()** -> Премахва елемент от началото на списъка (start)
<pre>
     start                                                 start
      v                                                      v
     ---    ---    ---    ---                               ---    ---    ---
l = | a |->| x |->| y |->| z |       l.pop_front() -> l =  | x |->| y |->| z |   
     ---    ---    ---    ---                               ---    ---    ---
</pre>

```c++
template <typename T>
void pop_front(Node<T>*& head) {
  if(!head) return;

  Node<T>* to_be_deleted = head;
  head = head->next;
  delete to_be_deleted;
}
```

- **empty()** -> Проверява дали списъкът е празен. Връща true, ако е така, и false в противен случай
<pre>
     start                 
      v                        
      ---    ---    ---    ---                               
l =  | a |->| x |->| y |->| z |     l.empty() -> false
      ---    ---    ---    ---    

     start                 
      v                                                  
l =  nullptr                        l.empty() -> true
                                  
</pre>


### STL forward_list

**Библиотека:** forward_list
**Дефиниция:**  std::forward_list<*T*> - празен едносвързан списък от тип *T*

**Вградени методи:**
- push_front(*x*) -> Добавя нов елемент със стойност *x* в началото на списъка
- pop_front() -> Премахва елемент от началото на списъка
- empty() -> Проверява дали списъка е празен. Връща true, ако е така, и false в противен случай
- insert_after(*pos*, *x*) -> Добавя нов елемент със стойност *x* след позиция *pos*, където *pos* е итератор
- erase_after(*pos*,) -> Изтрива елемента след позиция *pos*, където *pos* е итератор
- begin() -> Връща итератор към началото на списъка
- end() -> Връща итератор към края на списъка 
- remove(*x*) -> Изтрива всички елементи със стойност *x*
- remove_if(*condition*) -> Изтрива всички елементи, отговарящи на *condition* (булева функция)


### Итератор



## Задачи

#### Задача 1

Дадена е следната структура: 
```
Node { 
    T value; 
    Node* next; 
};
```

- Да се реализира функция, която приема указател към първия елемент на списък - елемент от тип **Node***, и връща указател към първия елемент на списък, съдържащ елементите на подадения списък в обратен ред
- Да се реализира функция, която приема указател към първия елемент на списък - елемент от тип **Node***, и стойност **Х** и модифицира подадения списък, изтривайки всички елементи със стойност, равна на **Х**.


##
#### Задача 2

Множество се нарича съвкупност от уникални данни с опции за добавяне и премахване на елементи и обединение и сечение с друго множество. Да се напише шаблонен клас **Set**, поддържащ елементите си в контейнер от тип **list** и реализиращ горепосочената функционалност.


##
#### Задача 3

Да се напише функция, която приема произволен списък и число **K**. Нека връща списък от списъци с дължина **К** (последният може да е по-къс - съдържащ толкова елемента, колкото е остатъка при деление на дължината на списъка на **K**), образуван от подадения списък.

### Пример: 

Нека L = {1, 3, 5, 234, 2.6, 3, 3, 985, -45, 3, 5.01}, K =4 \
**Резултат:** {{1, 3, 5, 234}, {2.6, 3, 3, 985}, {-45, 3, 5.01}}


##
#### Задача 4

На група рицари им доскучало - били убили всички дракони в кралството, а пътьом спечелили и ръцете на няколко принцеси. Затова решили да играят следната игра - наредили се около кръгла маса и всеки от тях намислил число. Първият се избира на псевдослучаен принцип (ако рицарите са **N** на брой, то **(((N%2)*4+8)/2)%N)** и играта стартира с намисленото от него число - **K**. Започва да се брои по часовниковата стрелка. Когато се стигне до пореден номер, равен на **K**, рицарят на тази позиция става от масата и играта продължава с неговото число. Победител е последно останалият на масата рицар. На стандартния вход се получават броя рицари и списък от намислените числа. На стандартния изход да се изведе числото, намислено от рицаря-победител.

### Пример: 
**Вход:** \ 
6 \
7 15 3 19 2 13 \
**Изход:** 2

