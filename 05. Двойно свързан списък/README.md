# Двойно свързан списък

## Синтаксис

Ще използваме следната структура, представяща елемент на списъка
```c++
template <typename T>
struct Node {   
  T value;          // стойност на полето
  Node<T>* next;    // връзка към следващото поле
  Node<T>* prev;    // връзка към предишното поле

  Node(const T& value, Node<T>* prev=nullptr, Node<T>* next=nullptr): value(value), prev(prev), next(next) {}
};
```

**Стандартни методи за работа с двусвързан списък:**
- **front()** -> Връща стойността на елемента, намиращ се в началото на списъка (start)
<pre>
     start            end
      v                v
      ---     ---     ---
l =  | x |<->| y |<->| z |       l.front() -> x
      ---     ---     ---
</pre>

- **back()** -> Връща стойността на елемента, намиращ се в края на списъка (end)
<pre>
     start            end
      v                v
      ---     ---     ---
l =  | x |<->| y |<->| z |       l.back() -> z
      ---     ---     ---
</pre>


- **push_front(*value*)** -> Добавя нов елемент със стойност *value* в началото на списъка (start)
<pre>
     start            end                                  start                   end
      v                v                                    v                       v
      ---     ---     ---                                  ---     ---     ---     ---
l =  | x |<->| y |<->| z |        l.push_front(a) -> l =  | a |<->| x |<->| y |<->| z |  
      ---     ---     ---                                  ---     ---     ---     ---
</pre>

```c++
template <typename T>
void push_front(const T& value, Node<T>*& head) {
  Node<T>* new_node = new Node<T>(value, nullptr, head);
  if(empty(head)) {
    end = new_node;
  } else {
    head->prev = new_node;
  }
  head = new_node;
}
```

- **push_back(*value*)** -> Добавя нов елемент със стойност *value* в края на списъка (end)
<pre>
     start            end                                  start                   end
      v                v                                    v                       v
      ---     ---     ---                                  ---     ---     ---     ---
l =  | x |<->| y |<->| z |        l.push_back(a) ->  l =  | x |<->| y |<->| z |<->| a |  
      ---     ---     ---                                  ---     ---     ---     ---
</pre>

```c++
template <typename T>
void push_back(const T& value, Node<T>*& head) {
  Node<T>* new_node = new Node<T>(value, end);
  if(empty(head)) {
    head = new_node;
  } else {
    end->next = new_node;
  }
  end = new_node;
}
```

- **pop_front()** -> Премахва елемент от началото на списъка (start)
<pre>
     start                   end                              start            end
      v                       v                                 v               v
     ---     ---     ---     ---                               ---     ---     ---
l = | a |<->| x |<->| y |<->| z |       l.pop_front() -> l =  | x |<->| y |<->| z |   
     ---     ---     ---     ---                               ---     ---     ---
</pre>

```c++
template <typename T>
void pop_front(Node<T>*& head) {
  if(!head) return;

  Node<T>* to_be_deleted = head;
  head = head->next;
  if (!head) end = nullptr;
  delete to_be_deleted;
}
```

- **pop_back()** -> Премахва елемент от края на списъка (end)
<pre>
     start                   end                              start            end
      v                       v                                 v               v
     ---     ---     ---     ---                               ---     ---     ---
l = | x |<->| y |<->| z |<->| a |       l.pop_back() ->  l =  | x |<->| y |<->| z |   
     ---     ---     ---     ---                               ---     ---     ---
</pre>

```c++
template <typename T>
void pop_back(Node<T>*& head) {
  if(!end) return;

  Node<T>* to_be_deleted = end;
  end = end->prev;
  if(!end) head = nullptr;
  delete to_be_deleted;
}
```

- **empty()** -> Проверява дали списъкът е празен. Връща true, ако е така, и false в противен случай
<pre>
     start                    end
      v                        v
      ---     ---     ---     ---                               
l =  | a |<->| x |<->| y |<->| z |     l.empty() -> false
      ---     ---     ---     ---    

     start                 
      v                                                  
l =  nullptr <-end                    l.empty() -> true                            
</pre>


### STL list

**Библиотека:** list
**Дефиниция:**  std::list<*T*> - празен двусвързан списък от тип *T*

**Вградени методи:**
- push_front(*x*) -> Добавя нов елемент със стойност *x* в началото на списъка
- push_back(*x*) -> Добавя нов елемент със стойност *x* в края на списъка
- pop_front() -> Премахва елемент от началото на списъка
- pop_back() -> Премахва елемент от края на списъка
- empty() -> Проверява дали списъка е празен. Връща true, ако е така, и false в противен случай
- insert(*pos*, *x*) -> Добавя нов елемент със стойност *x* преди позиция *pos*, където *pos* е итератор
- erase(*pos*,) -> Изтрива елемента след позиция *pos*, където *pos* е итератор
- begin() -> Връща итератор към началото на списъка
- end() -> Връща итератор към края на списъка 
- remove(*x*) -> Изтрива всички елементи със стойност *x*
- remove_if(*condition*) -> Изтрива всички елементи, отговарящи на *condition* (булева функция)


## Задачи 

#### Задача 1

Дадена е следната структура: 
```c++
template <typename T>
struct Node { 
    T value; 
    Node<T>* prev; 
    Node<T>* next; 
};
```

- Да се реализира функция, която приема указатели към първия елемент на два възходящо сортирани двусвързани списъка - елементи от тип **Node***, и връща указател към първия елемент на списък, съдържащ елементите на двата списъка, сортирани низходящо.
- Да се реализира функция, която приема указател към първия елемент на двусвързан списък - елемент от тип **Node***, и модифицира подадения списък, изтривайки всички повтарящи се елементи.
- Аномалия в двусвързан списък наричаме следната структура:

<pre>
        prev        prev           prev       prev
 -----  <---  ----- <---  ------ <---  -----  <---  -----
|  A  |      |  B  |     |   C  |     |  D  |      |  F  |
 -----  --->  ----- --->  ------       -----  --->  -----
        next        next     ^ | next  ^      next
                        prev | v       | next
                             ------------
                            |     E      |   
                             ------------
</pre>
Да се реализира функция, която приема указател към първия елемент на двусвързан списък - елемент от тип **Node***, и модифицира подадения списък, премахвайки всички аномалии.



## Задачи за едносвързан/двусвързан списък

#### Задача 2

Множество се нарича съвкупност от уникални данни с опции за добавяне и премахване на елементи и обединение и сечение с друго множество. Да се напише шаблонен клас **Set**, поддържащ елементите си в контейнер от тип **std::list** и реализиращ горепосочената функционалност.

*Решение с едносвързан списък: в "04. Свързан списък"*


##
#### Задача 3

Да се напише функция, която приема произволен списък и число **K**. Нека връща списък от списъци с дължина **К** (последният може да е по-къс - съдържащ толкова елемента, колкото е остатъка при деление на дължината на списъка на **K**), образуван от подадения списък.

### Пример: 

Нека L = {1, 3, 5, 234, 2.6, 3, 3, 985, -45, 3, 5.01}, K = 4 \
**Резултат:** {{1, 3, 5, 234}, {2.6, 3, 3, 985}, {-45, 3, 5.01}}
