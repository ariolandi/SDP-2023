# Графи

## Представяния на графи

Нека е даден ориентиран граф G(V, E):
<pre>
6 <-
^    \
|     \
1 <--- 2-----
|      ^     \
v      |      v
3 <--- 4 <--- 5 
</pre>

####  Списък на съседите:

1: 3, 6\
2: 1, 5\
3: \
4: 2, 3\
5: 4\
6:

| Предимства                                | Недостатъци                                          |
| ----------------------------------------- | ---------------------------------------------------- |
| пести памет                               | бавна проверка за наличието на ребро между два върха |
| лесно обхождане на съседите на даден връх |                                                      |

####  Матрица на съседство:

|   | 1 | 2 | 3 | 4 | 5 | 6 |
| - | - | - | - | - | - | - |
| 1 |   |   | X |   |   | X |
| 2 | X |   |   |   | X |   |
| 3 |   |   |   |   |   |   |
| 4 |   | X | X |   |   |   |
| 5 |   |   |   | X |   |   |
| 6 |   |   |   |   |   |   |


| Предимства                                         | Недостатъци                                    |
| -------------------------------------------------- | ---------------------------------------------- |
| лесна проверка за наличие на ребро между два върха | излишна памет                                  |
|                                                    | бавно откриване на всички съседи на даден връх |

## Обхождания на графи

Нека е даден неориентиран граф G(V, E) и начален връх s=4:
<pre>
   6
  /  \
 /    \
1 ---- 2 
|      | \     
3 ---- 4  5
</pre>

####  Обхождане в ширина:

<pre>
BFS(G, s):
  used[]
  queue
  path

  for v in G(V):
    used[v] <- false

  queue   <- s
  used[s] <- true


  while queue is not empty:
    v <- queue.front
    queue.pop
    path <- v

    for u in G.neighbours(v):
      if not used[u]:
        queue   <- u
        used[u] <- true

  return path
</pre>

Резултат на изпълнение: 4, 2, 1, 3, 6, 5


####  Обхождане в дълбочина:

<pre>
DFS_helper(G, v, used, path):
  used[v] <- true
  path    <- v

  for u in G.neighbours(v):
    if not used[u]:
      DFS_helper(G, u, used, path)


DFS(G, s):
  used[]
  path

  for v in G(V):
    used[v] <- false

  DFS_helper(G, s, used, path)
  
  return path
</pre>

Резултат на изпълнение: 4, 2, 3, 1, 5, 6

## Задачи

### Задача 1

В град има N на брой жители. Някои от тях са приятели. Но, според известната поговорка "приятелите на моите приятели са и мои приятели", ако А е приятел с B и B е приятел с C, то и А е приятел с С. Да се намери колко на брой са членовете на най-голямата приятелска група в града.

В началото на входа са дадени две цели положителни числа: N - брой жители, и M - брой известни двойки приятели. Следват M реда с по две числа 1 <= A, B <= N, за които се знае, че A и B са приятели един с друг.

#### Пример:

**Вход:**\
10 12\
1 2\
3 1\
3 4\
5 4\
3 5\
4 6\
5 2\
2 1\
7 1\
1 2\
9 10\
8 9\
**Изход:** 7

**Oбяснение на примера:**
<pre>
  7
 /
1 ------------ 2
 \   _________ |
  \ /         \|
   3 --- 4 --- 5 
         |
         6

8 --- 9 --- 10
</pre>

#
### Задача 2

Аня и Ванката са на път да намерят начин за придвижване във времето и пространството. Ванката е открил, че съществуват тунели през Космоса, всеки от тях свързващ две галактики. Те имат следните свойства:
- еднопосочни са
- всеки от тях има точно два края, всеки от тях намиращ се в различна галактика

Аня, от своя страна, повече се интересува дали случайно не може да съществува цикъл от тунели и по този начин да се загубят за вечни времена. Да се намерят всички възможни цикли в списъка с тунели на Аня и Ванката.

В началото на входните данни са дадени две цели положителни числа N и M - брой точки в пространството и брой тунели. Следват M реда с по две числа 1 <= A, B <= M, A != B - начална и крайна точка на всеки от тунелите. Да се изведе броя на циклите.
 
#### Пример:

**Вход:**\
5 7\
1 2\
2 3\
3 5\
5 2\
3 5\
1 4\
2 5\
**Изход:** 2

**Вход:**\
5 5\
1 2\
2 3\
1 4\
4 5\
5 3\
**Изход:** 0

#
### Задача 3

Дадено е стандартно поле за игра на шах, където колоните се отбелязват с малки латински букви **a-h**, а редовете - с цифри **1-8**. Адрес на поле се задава във формат **<номер на колона><номер на ред>**, например **a3**. Конят се движи по полето в L-образни ходове - две полета в която и да е посока и още едно поле перпендикулярно. Дадени са начална и крайна позиция на коня. Да се намери минималният брой ходове, необходими за придвижването му по дъската.

#### Пример:

**Вход:** h8 c3\
**Изход:** 4

**Илюстрация на ход на коня:**\
Със символ X е отбелязана позиция на коня, а със символ O - възможните за достигане позиции.

|   | a | b | c | d | e | f | g | h |
| - | - | - | - | - | - | - | - | - |
| 1 |   |   |   |   |   |   |   |   |
| 2 |   |   | O |   | O |   |   |   |
| 3 |   | O |   |   |   | O |   |   |
| 4 |   |   |   | X |   |   |   |   |
| 5 |   | O |   |   |   | O |   |   |
| 6 |   |   | O |   | O |   |   |   |
| 7 |   |   |   |   |   |   |   |   |
| 8 |   |   |   |   |   |   |   |   |
