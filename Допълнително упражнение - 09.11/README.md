## Стек

### Задача 1

Дадена е следната структура, която да се използва в решението без да бъде променяна:
```c++
template <typename T>
struct Node {
    T value;
    Node<T>* next;
};
```

Дефинираме обратен полски израз рекурсивно по следния начин:
- операция := + | - | * | /
- израз := число | израз израз операция

Да се напише програмен фрагмент, който пресмята така зададен израз с помощта на стек. Предполага се, че всички операции са оградени от скоби и не се спазва стандартния им приоритет. 

#### Пример:
45 2 * 4 - 2 / 3 * -> (45 * (2 - (4 / (2 * 3)) -> 90

Задачата да се реши и спазвайки приоритет на операциите: +, -, *, /.

#### Пример:
45 2 * 4 - 2 / 3 * -> 45 * 2 - 4 / 2 * 3 -> ((45 * 2) - ((4 / 2) * 3)) -> 84

##
### Задача 2

**За решението да се използва std::stack.**

Коледа е още далеч, но джуджетата вече се подготвят усърдно за празника. Те са се наредили в редица, номерирана последователно от **1** до **N**. Всяко от тях разполага с купчина подаръци, всеки от които с идентификационен номер, които да опакова. Периодично се извършват следните действия: 
- **join** - джудже се включва в края на редицата под номер **N+1**
- **add X Y** - джудже **X** получава подарък с номер **Y**, който се слага най-отгоре на съответната купчина
- **ready X** - джудже **X** е готово с поредния подарък

Всяко джудже в началото започва с празна купчина. Дадена е поредица от **M** команди. Да се изведат всички готови подаръци в реда, в който са опаковани.

#### Пример: 
**Вход:** \
12 \
join \
join \
add 2 34 \
add 2 3 \
add 1 56 \
ready 1 \
ready 2 \
join \
add 1 5 \
add 3 21 \
ready 3 \
ready 2 

**Изход:** 
56 3 21 34


##
## Опашка

##
### Задача 3

**За решението да се използва std::queue.**

Аня и Ванката са измислили нова бордова игра. Тя се състои в раздаване на роли, всяка от които със следните специални умения:
- **KILL** - изважда друг играч от играта незабавно
- **PASS** - блокира друг играч и отнема правото му на ход за дадения рунд, ако той играе след него
- **AWAY** - изважда друг играч от играта след края на дадения рунд

Освен роля, всеки играч разполага и с идентификационен номер от **1** до **N**, раздаден на случаен принцип. Играчите се редуват да изпълняват ходовете си в съответствие със съответната роля. Победител е последния останал участник.

Да се напише програма, която по брой участници **N**, техните съответни идентификационни номера и специални роли, както и избора за действие на всеки за **M** рунда извежда на стандартния изход обобщение за игровата ситуация. За всеки рунд **всеки от N-те** играча посочва своя ход. Ако даден играч е изваден от игра, то той се прескача. Ако дадено действие е насочено към играч, който не е в играта, то то се прескача.

#### Пример: 
**Вход:** \
6 \
5 KILL \
2 AWAY \
4 KILL \
1 KILL \
3 PASS \
6 AWAY \
3 \
4 3 2 4 6 2 \
1 3 5 2 2 3 \
2 4 5 6 6 2

**Изход:** \
Round 1: players 4, 3 are out of game; players 5, 2, 1, 6 are still in game \
Round 2: players 2, 1 are out of game; players 5, 6 are still in game \
Round 3: no players are out of game; players 5, 6 are still in game 

**Илюстрация на примера:** 

Рунд 1: \
(5, KILL) (2, PASS) (4, KILL) (1, KILL) (3, PASS) (6, AWAY) \
Играч 5: изважда играч 4 от игра \
Играч 2: прогонва играч 3 в края на рунда \
Играч 4: действието се пропуска \
Играч 1: играч 4 е извън игра, действието се пропуска \
Играч 3: блокира играч 6, действието се пропуска \
Играч 6: играчът е блокиран, действието се пропуска 

Рунд 2: \
(5, KILL) (2, PASS) (4, _) (1, KILL) (3, _) (6, AWAY) \
Играч 5: изважда играч 1 от игра \
Играч 2: играч 3 е извън игра, действието се пропуска \
Играч 4: действието се пропуска \
Играч 1: изважда играч 2 от игра \
Играч 3: действието се пропуска \
Играч 6: играч 3 е извън игра, действието се пропуска

Рунд 3: \
(5, KILL) (2, _) (4, _) (1, _) (3, _) (6, AWAY) \
Играч 5: играч 2 е извън игра, действието се пропуска \
Играч 2: действието се пропуска \
Играч 4: действието се пропуска \
Играч 1: действието се пропуска \
Играч 3: действието се пропуска \
Играч 6: играч 2 е извън игра, действието се пропуска

След рунд 3: \
(5, KILL) (2, _) (4, _) (1, _) (3, _) (6, AWAY)

##
## Списък

### Задача 4

Цикличен списък с една връзка наричаме следната структура:
<pre> 
 head
 -----        -----        -----
|  A  | ---> |  B  | ---> |  C  |
 -----        -----        -----  
   ^                         |
   |                         |
    ------------------------- 
</pre>

Дадена е следната структура, която да се използва в решението без да бъде променяна:
```c++
template <typename T>
struct Node {
    T value;
    Node<T>* next;
};
```
**За решението да се използва цикличен списък с една връзка.** 

На група рицари им доскучало - били убили всички дракони в кралството, а пътьом спечелили и ръцете на няколко принцеси. Затова решили да играят следната игра - наредили се около кръгла маса и всеки от тях намислил число. Първият се избира на псевдослучаен принцип (ако рицарите са **N** на брой, то **(((N%2)\*4+8)/2)%N)** и играта стартира с намисленото от него число - **K**. Започва да се брои по часовниковата стрелка. Когато се стигне до пореден номер, равен на **K**, рицарят на тази позиция става от масата и играта продължава с неговото число. Победител е последно останалият на масата рицар. На стандартния вход се получават броя рицари и списък от намислените числа. На стандартния изход да се изведе числото, намислено от рицаря-победител.

#### Пример: 
**Вход:** \
6 \
7 15 3 19 2 13 \
**Изход:** 2


##
### Задача 5

**За решението да се използва std::list или std::forward_list.**

Даден е списък от списъци от произволен тип. Да се напише функция flatten_unique, която връща нов списък, съдържащ елементите на вложените списъци без повторение:

#### Пример: 
{{1, 3, 1}, {}, {2}, {3, 3, 56, -1}} -> {1, 3, 2, 56, -1}


